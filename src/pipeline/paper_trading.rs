//! Paper Trading Module for LVN Retest Strategy
//!
//! Validates the strategy in real-time without risking capital.
//! Tracks signals, simulates entries/exits, and logs results.

use chrono::{DateTime, Datelike, Timelike, Utc, Local};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::fs::{File, OpenOptions};
use std::io::{BufReader, BufWriter, Write};
use std::path::PathBuf;

use crate::bars::Bar;
use crate::impulse::ImpulseDirection;
use crate::lvn::LvnLevel;
use crate::market_state::{detect_market_state, MarketState, MarketStateConfig};

/// Paper trading configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PaperConfig {
    /// Level tolerance for "at level" detection
    pub level_tolerance: f64,
    /// Distance to arm level for retest
    pub retest_distance: f64,
    /// Minimum delta for signal
    pub min_delta: i64,
    /// Maximum range for signal (absorption)
    pub max_range: f64,
    /// Take profit in points
    pub take_profit: f64,
    /// Trailing stop distance
    pub trailing_stop: f64,
    /// Structure stop buffer (beyond LVN)
    pub stop_buffer: f64,
    /// Max LVN volume ratio
    pub max_lvn_ratio: f64,
    /// Trading start hour (ET)
    pub start_hour: u32,
    /// Trading start minute
    pub start_minute: u32,
    /// Trading end hour (ET)
    pub end_hour: u32,
    /// Trading end minute
    pub end_minute: u32,
}

impl Default for PaperConfig {
    fn default() -> Self {
        Self {
            level_tolerance: 2.5,
            retest_distance: 8.0,
            min_delta: 75,
            max_range: 2.5,
            take_profit: 35.0,
            trailing_stop: 12.0,
            stop_buffer: 0.5,
            max_lvn_ratio: 0.15,
            start_hour: 9,
            start_minute: 30,
            end_hour: 11,
            end_minute: 0,
        }
    }
}

/// State of a tracked LVN level
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum LevelState {
    Untouched,
    Touched,
    Armed,
    Retesting,
}

/// Tracked LVN level
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TrackedLevel {
    pub price: f64,
    pub state: LevelState,
    pub impulse_direction: ImpulseDirection,
    pub volume_ratio: f64,
    pub created_date: String,
    pub first_touch_time: Option<DateTime<Utc>>,
    pub armed_time: Option<DateTime<Utc>>,
}

/// Trade direction
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum Direction {
    Long,
    Short,
}

impl std::fmt::Display for Direction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Direction::Long => write!(f, "LONG"),
            Direction::Short => write!(f, "SHORT"),
        }
    }
}

/// Paper trade status
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum TradeStatus {
    Open,
    ClosedWin,
    ClosedLoss,
    ClosedBreakeven,
}

/// A paper trade
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PaperTrade {
    pub id: u32,
    pub entry_time: DateTime<Utc>,
    pub exit_time: Option<DateTime<Utc>>,
    pub direction: Direction,
    pub entry_price: f64,
    pub exit_price: Option<f64>,
    pub stop_loss: f64,
    pub take_profit: f64,
    pub trailing_stop: f64,
    pub highest_price: f64,
    pub lowest_price: f64,
    pub level_price: f64,
    pub pnl_points: Option<f64>,
    pub status: TradeStatus,
    pub entry_reason: String,
    pub exit_reason: Option<String>,
}

/// Signal generated by the strategy
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Signal {
    pub timestamp: DateTime<Utc>,
    pub direction: Direction,
    pub price: f64,
    pub level_price: f64,
    pub delta: i64,
    pub range: f64,
    pub impulse_direction: ImpulseDirection,
    pub market_state: String,
}

/// Daily summary
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DailySummary {
    pub date: String,
    pub signals: u32,
    pub trades: u32,
    pub wins: u32,
    pub losses: u32,
    pub breakevens: u32,
    pub total_pnl: f64,
    pub max_drawdown: f64,
}

/// Paper trading state
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PaperTradingState {
    pub config: PaperConfig,
    pub tracked_levels: HashMap<i64, TrackedLevel>,
    pub signals: Vec<Signal>,
    pub trades: Vec<PaperTrade>,
    pub current_trade: Option<PaperTrade>,
    pub next_trade_id: u32,
    pub daily_summaries: Vec<DailySummary>,
    pub bars_buffer: Vec<Bar>,
}

impl PaperTradingState {
    pub fn new(config: PaperConfig) -> Self {
        Self {
            config,
            tracked_levels: HashMap::new(),
            signals: Vec::new(),
            trades: Vec::new(),
            current_trade: None,
            next_trade_id: 1,
            daily_summaries: Vec::new(),
            bars_buffer: Vec::new(),
        }
    }

    /// Load state from file
    pub fn load(path: &PathBuf) -> Option<Self> {
        if path.exists() {
            let file = File::open(path).ok()?;
            let reader = BufReader::new(file);
            serde_json::from_reader(reader).ok()
        } else {
            None
        }
    }

    /// Save state to file
    pub fn save(&self, path: &PathBuf) -> std::io::Result<()> {
        let file = File::create(path)?;
        let writer = BufWriter::new(file);
        serde_json::to_writer_pretty(writer, self)?;
        Ok(())
    }

    /// Add LVN levels from today's impulse legs
    pub fn add_lvn_levels(&mut self, levels: &[LvnLevel]) {
        for lvn in levels {
            if lvn.volume_ratio > self.config.max_lvn_ratio {
                continue;
            }

            let key = (lvn.price * 10.0) as i64;
            self.tracked_levels.insert(key, TrackedLevel {
                price: lvn.price,
                state: LevelState::Untouched,
                impulse_direction: lvn.impulse_direction,
                volume_ratio: lvn.volume_ratio,
                created_date: lvn.date.to_string(),
                first_touch_time: None,
                armed_time: None,
            });
        }
    }

    /// Clear levels for new session
    pub fn clear_levels(&mut self) {
        self.tracked_levels.clear();
    }

    /// Check if current time is within trading hours
    fn is_trading_hours(&self, ts: DateTime<Utc>) -> bool {
        let hour = ts.hour();
        let minute = ts.minute();
        let time_mins = hour * 60 + minute;

        // Convert ET to UTC (add 5 hours)
        let start_utc = (self.config.start_hour + 5) * 60 + self.config.start_minute;
        let end_utc = (self.config.end_hour + 5) * 60 + self.config.end_minute;

        time_mins >= start_utc && time_mins < end_utc
    }

    /// Process a new bar
    pub fn process_bar(&mut self, bar: &Bar) -> Option<Signal> {
        // Add to buffer for market state calculation
        self.bars_buffer.push(bar.clone());
        if self.bars_buffer.len() > 120 {
            self.bars_buffer.remove(0);
        }

        // Update any open trade
        if let Some(ref mut trade) = self.current_trade {
            update_open_trade(trade, bar, &self.config);
            if trade.status != TradeStatus::Open {
                let closed_trade = self.current_trade.take().unwrap();
                self.trades.push(closed_trade);
            }
        }

        // Skip if outside trading hours
        if !self.is_trading_hours(bar.timestamp) {
            return None;
        }

        // Skip if we have an open trade
        if self.current_trade.is_some() {
            return None;
        }

        // Update level states
        self.update_level_states(bar);

        // Check for signal
        self.check_for_signal(bar)
    }

    /// Update level states based on current price
    fn update_level_states(&mut self, bar: &Bar) {
        let price = bar.close;

        for level in self.tracked_levels.values_mut() {
            let distance = (price - level.price).abs();

            match level.state {
                LevelState::Untouched => {
                    if distance <= self.config.level_tolerance {
                        level.state = LevelState::Touched;
                        level.first_touch_time = Some(bar.timestamp);
                    }
                }
                LevelState::Touched => {
                    if distance > self.config.retest_distance {
                        level.state = LevelState::Armed;
                        level.armed_time = Some(bar.timestamp);
                    }
                }
                LevelState::Armed => {
                    if distance <= self.config.level_tolerance {
                        level.state = LevelState::Retesting;
                    }
                }
                LevelState::Retesting => {
                    if distance > self.config.level_tolerance * 2.0 {
                        if distance > self.config.retest_distance {
                            level.state = LevelState::Armed;
                        } else {
                            level.state = LevelState::Touched;
                        }
                    }
                }
            }
        }
    }

    /// Check for entry signal
    fn check_for_signal(&mut self, bar: &Bar) -> Option<Signal> {
        // Need enough bars for market state
        if self.bars_buffer.len() < 60 {
            return None;
        }

        // Check market state
        let market_config = MarketStateConfig::default();
        let bar_idx = self.bars_buffer.len() - 1;
        let market_state = detect_market_state(&self.bars_buffer, bar_idx, &market_config);

        if market_state.state != MarketState::Imbalanced {
            return None;
        }

        let price = bar.close;
        let delta = bar.delta;
        let range = bar.high - bar.low;

        // Check delta threshold
        if delta.abs() < self.config.min_delta {
            return None;
        }

        // Check range (absorption)
        if range > self.config.max_range {
            return None;
        }

        // Find retesting level
        for (_, level) in &self.tracked_levels {
            if level.state != LevelState::Retesting {
                continue;
            }

            let distance = (price - level.price).abs();
            if distance > self.config.level_tolerance {
                continue;
            }

            // Determine direction based on impulse
            let trade_direction = match level.impulse_direction {
                ImpulseDirection::Up => Direction::Long,
                ImpulseDirection::Down => Direction::Short,
            };

            // Check for trend continuation (delta in trend direction)
            let is_continuation = match trade_direction {
                Direction::Long => delta > 0,
                Direction::Short => delta < 0,
            };

            if !is_continuation {
                continue;
            }

            // Generate signal
            let signal = Signal {
                timestamp: bar.timestamp,
                direction: trade_direction,
                price,
                level_price: level.price,
                delta,
                range,
                impulse_direction: level.impulse_direction,
                market_state: format!("{:?}", market_state.state),
            };

            self.signals.push(signal.clone());

            // Open paper trade
            let stop_loss = match trade_direction {
                Direction::Long => level.price - self.config.stop_buffer,
                Direction::Short => level.price + self.config.stop_buffer,
            };

            let take_profit = match trade_direction {
                Direction::Long => price + self.config.take_profit,
                Direction::Short => price - self.config.take_profit,
            };

            self.current_trade = Some(PaperTrade {
                id: self.next_trade_id,
                entry_time: bar.timestamp,
                exit_time: None,
                direction: trade_direction,
                entry_price: price,
                exit_price: None,
                stop_loss,
                take_profit,
                trailing_stop: stop_loss,
                highest_price: price,
                lowest_price: price,
                level_price: level.price,
                pnl_points: None,
                status: TradeStatus::Open,
                entry_reason: format!(
                    "LVN retest at {:.2}, delta={}, range={:.2}",
                    level.price, delta, range
                ),
                exit_reason: None,
            });
            self.next_trade_id += 1;

            return Some(signal);
        }

        None
    }


    /// Get current open trade info
    pub fn get_open_trade(&self) -> Option<&PaperTrade> {
        self.current_trade.as_ref()
    }

    /// Get all closed trades
    pub fn get_closed_trades(&self) -> &[PaperTrade] {
        &self.trades
    }

    /// Get today's trades
    pub fn get_todays_trades(&self) -> Vec<&PaperTrade> {
        let today = Utc::now().date_naive();
        self.trades
            .iter()
            .filter(|t| t.entry_time.date_naive() == today)
            .collect()
    }

    /// Calculate statistics
    pub fn calculate_stats(&self) -> TradingStats {
        let closed: Vec<_> = self.trades.iter().filter(|t| t.status != TradeStatus::Open).collect();

        if closed.is_empty() {
            return TradingStats::default();
        }

        let wins: Vec<_> = closed.iter().filter(|t| t.status == TradeStatus::ClosedWin).collect();
        let losses: Vec<_> = closed.iter().filter(|t| t.status == TradeStatus::ClosedLoss).collect();

        let total_pnl: f64 = closed.iter().filter_map(|t| t.pnl_points).sum();
        let gross_profit: f64 = closed.iter().filter_map(|t| t.pnl_points).filter(|&p| p > 0.0).sum();
        let gross_loss: f64 = closed.iter().filter_map(|t| t.pnl_points).filter(|&p| p < 0.0).map(|p| p.abs()).sum();

        let avg_win = if !wins.is_empty() {
            wins.iter().filter_map(|t| t.pnl_points).sum::<f64>() / wins.len() as f64
        } else {
            0.0
        };

        let avg_loss = if !losses.is_empty() {
            losses.iter().filter_map(|t| t.pnl_points).sum::<f64>() / losses.len() as f64
        } else {
            0.0
        };

        let profit_factor = if gross_loss > 0.0 { gross_profit / gross_loss } else { 0.0 };
        let win_rate = wins.len() as f64 / closed.len() as f64 * 100.0;
        let rr_ratio = if avg_loss.abs() > 0.01 { avg_win / avg_loss.abs() } else { 0.0 };

        TradingStats {
            total_trades: closed.len() as u32,
            wins: wins.len() as u32,
            losses: losses.len() as u32,
            win_rate,
            total_pnl,
            avg_win,
            avg_loss,
            profit_factor,
            rr_ratio,
        }
    }

    /// Print status
    pub fn print_status(&self) {
        let stats = self.calculate_stats();
        let now = Local::now();

        println!("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
        println!("â•‘           PAPER TRADING STATUS - {}            â•‘", now.format("%Y-%m-%d %H:%M"));
        println!("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");

        println!("â•‘ Trading Window: {:02}:{:02} - {:02}:{:02} ET                          â•‘",
            self.config.start_hour, self.config.start_minute,
            self.config.end_hour, self.config.end_minute);

        println!("â•‘ Tracked Levels: {:3}                                       â•‘", self.tracked_levels.len());

        let retesting: Vec<_> = self.tracked_levels.values()
            .filter(|l| l.state == LevelState::Retesting)
            .collect();
        let armed: Vec<_> = self.tracked_levels.values()
            .filter(|l| l.state == LevelState::Armed)
            .collect();

        println!("â•‘   Armed: {:3}  |  Retesting: {:3}                           â•‘", armed.len(), retesting.len());
        println!("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");

        if let Some(trade) = &self.current_trade {
            let current_pnl = match trade.direction {
                Direction::Long => self.bars_buffer.last().map(|b| b.close - trade.entry_price).unwrap_or(0.0),
                Direction::Short => self.bars_buffer.last().map(|b| trade.entry_price - b.close).unwrap_or(0.0),
            };
            println!("â•‘ ğŸ”´ OPEN TRADE: {} @ {:.2}                        â•‘", trade.direction, trade.entry_price);
            println!("â•‘    P&L: {:+.2} pts  |  Trail: {:.2}  |  TP: {:.2}       â•‘",
                current_pnl, trade.trailing_stop, trade.take_profit);
        } else {
            println!("â•‘ No open trade - Waiting for signal...                     â•‘");
        }

        println!("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
        println!("â•‘ SESSION STATS                                             â•‘");
        println!("â•‘   Trades: {:3}  |  Signals: {:3}                           â•‘", stats.total_trades, self.signals.len());
        println!("â•‘   Wins: {:3}  |  Losses: {:3}  |  WR: {:.1}%               â•‘", stats.wins, stats.losses, stats.win_rate);
        println!("â•‘   P&L: {:+.2} pts  |  PF: {:.2}  |  R:R: {:.2}:1         â•‘", stats.total_pnl, stats.profit_factor, stats.rr_ratio);
        println!("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    }
}

/// Update an open trade with new bar data
fn update_open_trade(trade: &mut PaperTrade, bar: &Bar, config: &PaperConfig) {
    trade.highest_price = trade.highest_price.max(bar.high);
    trade.lowest_price = trade.lowest_price.min(bar.low);

    match trade.direction {
        Direction::Long => {
            // Update trailing stop
            if trade.highest_price >= trade.entry_price + config.trailing_stop {
                let new_trail = trade.highest_price - config.trailing_stop;
                if new_trail > trade.trailing_stop {
                    trade.trailing_stop = new_trail;
                }
            }

            // Check stop
            if bar.low <= trade.trailing_stop {
                trade.exit_time = Some(bar.timestamp);
                trade.exit_price = Some(trade.trailing_stop);
                let pnl = trade.trailing_stop - trade.entry_price;
                trade.pnl_points = Some(pnl);
                trade.status = if pnl > 0.5 {
                    TradeStatus::ClosedWin
                } else if pnl < -0.5 {
                    TradeStatus::ClosedLoss
                } else {
                    TradeStatus::ClosedBreakeven
                };
                trade.exit_reason = Some(format!("Trailing stop at {:.2}", trade.trailing_stop));
            }
            // Check target
            else if bar.high >= trade.take_profit {
                trade.exit_time = Some(bar.timestamp);
                trade.exit_price = Some(trade.take_profit);
                trade.pnl_points = Some(trade.take_profit - trade.entry_price);
                trade.status = TradeStatus::ClosedWin;
                trade.exit_reason = Some(format!("Take profit at {:.2}", trade.take_profit));
            }
        }
        Direction::Short => {
            // Update trailing stop
            if trade.lowest_price <= trade.entry_price - config.trailing_stop {
                let new_trail = trade.lowest_price + config.trailing_stop;
                if new_trail < trade.trailing_stop {
                    trade.trailing_stop = new_trail;
                }
            }

            // Check stop
            if bar.high >= trade.trailing_stop {
                trade.exit_time = Some(bar.timestamp);
                trade.exit_price = Some(trade.trailing_stop);
                let pnl = trade.entry_price - trade.trailing_stop;
                trade.pnl_points = Some(pnl);
                trade.status = if pnl > 0.5 {
                    TradeStatus::ClosedWin
                } else if pnl < -0.5 {
                    TradeStatus::ClosedLoss
                } else {
                    TradeStatus::ClosedBreakeven
                };
                trade.exit_reason = Some(format!("Trailing stop at {:.2}", trade.trailing_stop));
            }
            // Check target
            else if bar.low <= trade.take_profit {
                trade.exit_time = Some(bar.timestamp);
                trade.exit_price = Some(trade.take_profit);
                trade.pnl_points = Some(trade.entry_price - trade.take_profit);
                trade.status = TradeStatus::ClosedWin;
                trade.exit_reason = Some(format!("Take profit at {:.2}", trade.take_profit));
            }
        }
    }
}

/// Trading statistics
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct TradingStats {
    pub total_trades: u32,
    pub wins: u32,
    pub losses: u32,
    pub win_rate: f64,
    pub total_pnl: f64,
    pub avg_win: f64,
    pub avg_loss: f64,
    pub profit_factor: f64,
    pub rr_ratio: f64,
}

/// Log a signal to file
pub fn log_signal(signal: &Signal, log_path: &PathBuf) -> std::io::Result<()> {
    let mut file = OpenOptions::new()
        .create(true)
        .append(true)
        .open(log_path)?;

    let local_time: DateTime<Local> = signal.timestamp.into();
    writeln!(
        file,
        "[{}] SIGNAL: {} @ {:.2} | Level: {:.2} | Delta: {} | Range: {:.2} | Impulse: {:?}",
        local_time.format("%Y-%m-%d %H:%M:%S"),
        signal.direction,
        signal.price,
        signal.level_price,
        signal.delta,
        signal.range,
        signal.impulse_direction,
    )?;

    Ok(())
}

/// Log a trade to file
pub fn log_trade(trade: &PaperTrade, log_path: &PathBuf) -> std::io::Result<()> {
    let mut file = OpenOptions::new()
        .create(true)
        .append(true)
        .open(log_path)?;

    let entry_local: DateTime<Local> = trade.entry_time.into();

    if let (Some(exit_time), Some(exit_price), Some(pnl)) = (trade.exit_time, trade.exit_price, trade.pnl_points) {
        let exit_local: DateTime<Local> = exit_time.into();
        writeln!(
            file,
            "[{}] TRADE #{}: {} | Entry: {:.2} @ {} | Exit: {:.2} @ {} | P&L: {:+.2} pts | {}",
            exit_local.format("%Y-%m-%d %H:%M:%S"),
            trade.id,
            trade.direction,
            trade.entry_price,
            entry_local.format("%H:%M:%S"),
            exit_price,
            exit_local.format("%H:%M:%S"),
            pnl,
            trade.exit_reason.as_deref().unwrap_or(""),
        )?;
    } else {
        writeln!(
            file,
            "[{}] TRADE #{}: {} | Entry: {:.2} | OPEN | SL: {:.2} | TP: {:.2}",
            entry_local.format("%Y-%m-%d %H:%M:%S"),
            trade.id,
            trade.direction,
            trade.entry_price,
            trade.stop_loss,
            trade.take_profit,
        )?;
    }

    Ok(())
}

/// Print an alert for a new signal (with sound hint)
pub fn print_signal_alert(signal: &Signal) {
    let local_time: DateTime<Local> = signal.timestamp.into();

    println!("\n");
    println!("ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨");
    println!("ğŸš¨                                                          ğŸš¨");
    println!("ğŸš¨  NEW SIGNAL: {}                                       ğŸš¨", signal.direction);
    println!("ğŸš¨  Price: {:.2}  |  Level: {:.2}                          ğŸš¨", signal.price, signal.level_price);
    println!("ğŸš¨  Delta: {}  |  Impulse: {:?}                      ğŸš¨", signal.delta, signal.impulse_direction);
    println!("ğŸš¨  Time: {}                                    ğŸš¨", local_time.format("%H:%M:%S"));
    println!("ğŸš¨                                                          ğŸš¨");
    println!("ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨ğŸš¨");
    println!("\n");

    // Play system bell
    print!("\x07");
    std::io::stdout().flush().ok();
}
